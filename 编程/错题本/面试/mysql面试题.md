---
日期: 2024-03-17
tags:
  - 问题错题
  - 面试
---
# 1.表没有主键可以吗？可以不设置主键吗
>在 [[mysql]] 中，表没有主键是可以的，但是不建议这样做。
>如果你没有显式地指定主键，InnoDB 将会自动创建一个隐藏的主键作为聚集索引，它是一个称为 ROWID 的 6 字节的长整型数字，用于唯一标识表中的每一行。

# 2.数据库3范式
*首先:我要明白数据库3范式是我们设计数据表的要求,而不是[[mysql]]等数据库的数据结构要求*
>**第一范式:** 列不可再分
>**第二范式:** 行可唯一区分
>**第三范式:** 表的非主属性不能依赖与其他表的非主属性

>[!NOTE]- 举例理解：
>第二范式（2NF）
>
考虑一个图书订单系统的订单表，其中包含以下列：订单号（OrderID）、客户名（CustomerName）、书籍ISBN号（BookISBN）、书名（BookTitle）、作者（Author）和作者国籍（AuthorNationality）。
>
在这个例子中，候选键可能是订单号（OrderID），因为订单号唯一标识了每个订单。现在我们来看看是否符合第二范式。
>
**非主属性部分依赖：** 作者（Author）和作者国籍（AuthorNationality）依赖于书籍ISBN号（BookISBN），而不是完全依赖于候选键（OrderID）。
>
为了符合第二范式，我们需要将这些部分依赖关系消除。一种方法是将作者（Author）和作者国籍（AuthorNationality）这两列移至一个独立的书籍信息表中，该表的候选键是书籍ISBN号（BookISBN）。
>
示例2：第三范式（3NF）
 **传递依赖：** 假设我们在订单表中还添加了一个列：作者国籍（AuthorNationality）。这种情况下，书籍ISBN号（BookISBN）和作者国籍（AuthorNationality）之间存在传递依赖关系，因为作者国籍直接依赖于作者（Author），而作者又依赖于书籍ISBN号（BookISBN）。
>
>为了符合第三范式，我们需要进一步分解表，确保每个非主属性都直接依赖于候选键。我们可以创建一个作者表，其中包含作者和作者国籍信息，候选键是作者名字，然后在订单表中使用作者名字作为外键来引用作者表。


# 3.数据库事务的特性（ACID）
1. **原子性**：必须全部成功才提交
2. **一致性**：事务成功后，业务和数据库保持一致
3. **隔离性**：事务与事务不会彼此干扰
4. **持久性**：一旦事务提交，事务就要持久化到数据库


# 4.mysql事务级别
从低到高为：
1.**读未提交**：脏读，不可重复读，幻读
2.**读已提交**：不可重复读，幻读
3.**可重复读**：幻读
4.**串行化**：排队一个个执行，不存在问题

# 5.并发事务带来的问题
1. 脏读：==读到未提交的数据==
2. 不可重复读： 当B事务**修改**且提交的时候，A事务读取到与之前不一致
3. 幻读：当B事务**插入**且提交的时候，A事务读取到与之前不一致数量
# 6.Mysql默认隔离基别是如何实现
通过MVCC（多版本并发控制）来实现。
	1.实现undolog 里面保存了多个版本
	2.readview,来读取版本，最小活跃id，最大id，当前id来判断，按照这个规则读到的是同一个规则，就解决了不可重复读的问题
# 7.MySQL ⽇志有了解过吗？
Mysql日志分为
bin log(属于MySQL 服务层内置日志),redo log，undo log（两者属于InnoDB引擎层的日志）
1. binlog （二进制日志）即存档⽇志，是 Server 层⽣成的的⽇志，主要⽤于==数据备份和主从复制==；
2. undolog（回滚⽇志），是回滚事务，记录了==事务执行修改操作之前的数据状态==。
3. redolog（重做⽇志），是 Innodb 存储引擎层的⽇志，==在数据库崩溃时==，通过==重放Redo Log==中的操作，==将数据库恢复到崩溃前的状态==；
# 8.数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？
1. 数据库==索引是⼀种数据结构==，==⽤于提⾼数据库表的查询效率==。它包含⼀些指向表中数据的指针，可以快速地定位到满⾜查询条件的数据⾏，从⽽提⾼查询效率。
2. 适合使⽤索引的场景包括：
	1. ==频繁查询的列==，如主键、外键等。
	2. ==经常作为查询条件的列==，如 WHERE、ORDER BY、GROUP BY 等语句中的列。
	3. ==经常需要连接的列==，如多表联合查询时的列。
	4. ==数据量较⼤的表==，通过索引可以加快数据检索速度。
# 9.索引失效，sql优化

## SQL优化
### 索引失效
1. 避免使用select \*
2. 避免使⽤sql函数、计算、类型转换
(使⽤这些以后，索引中存的不是函数计算后的值，⾃然⽤不到索引)
3. 避免like,>,< 
4. 使用or要两边都为索引。
==确保查询条件与索引列数据类型严格一致==，避免隐式类型转换
对于==全文搜索和模糊匹配==，考虑使用==MySQL全文索引==或借助==Elasticsearch等全文搜索引擎==

SQL优化
1.  避免索引失效
2.  **查询尽量避免大数据返回**，可以采用分页
3. **使用批量操作**，避免循环执行插入，修改，删除
4. **尽量采用数值代替字符串**类型
5. 尽量用用**连接查询**代**替子查询**
6. 使用group by应该==先过滤后分组==
7. 尽量使用**union all**替代**union**
8. **小表**驱动**大表**    如：`select * from orderwhere user_id in (select id from user where status=1)`
9. **索引不宜太多**，一般5个以内
10. 内连接，左连接，右连接，==优先内连接==


# 10.一条SQL语句在MySQL中的执行过程是怎么样的？
1. 先通过**连接器**与客户端建立连接、获取权限。
2. 然后**查询缓存**，查询缓存主要用来缓存我们所执行的 select语句以及该语句的结果集。（在**MySQL 8.0 版本后移除**）。
3. **语法分析和解析**,确保SQL语句的语法正确性。
4. **查询优化**，MySQL 会对 SQL 语句进⾏优化，==以确定最优的执⾏计划。==例如索引、表连接等
5. **查询执⾏**，==在查询优化后==，MySQL 开始执⾏==查询，读取和处理数据==。
6.  **结果返回**,MySQL 会将查询结果返回给客户端。

# 11.MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别，为什么MySQL 要⽤ B+ 树？


# 12.InnoDB存储引擎为什么选用B+tree索引？
1. 相对于二叉树，层级少，搜索效率高。
2. 
