---
tags:
  - 面试
  - 问题错题
---
# 1.java语言中的数据类型8种
## 基本数据类型
1.整数类型：`byte` `short` `int` `long`
2.浮点类型： `float` `double`
3.字符类型 `char`
4.逻辑类型 `boolean`
## 引用数据类型
1.`类` 如String,Object 2.`接口` 3.`数组` 
# 2.你知道Math.round?
math.round是进行4舍5入原理
-11.5 =-11.0
11.5=12

(round读：run的)
# 3.访问修饰符的区别？
访问修饰符有private,default,protected(泼太踢),pubilc
private 只能==当前类==访问，不能修饰类
default ==当前类==，==当前包==访问
protected ==当前类==,==当前包==和==子类==访问，不能修饰类
public ==当前类==，==当前包==和==子类==，==其他包==都可以访问
# 4.& 和&&的区别？
&&是==短路与==，当左边为false直接返回false
而&，要判断完左右两边，遇到false才返回false，同时为true才返回true。

# 5.final有什么用？
final用于修饰==类==，==属性==和==方法==。
1.被final修饰的==属性==一但==被赋值==就不能==被重新赋值==，如果是==引用==，==引用不可变==，==引用的内容可变==。
2.被final修饰的==类== 不能被==继承==。
3.修饰的==方法==不能被==重写==。
4.被final修饰后的==变量在编译==时就被==赋值==，提高程序的执行效率。

# 6.java创建对象的方式
1.通过==new关键字==来创建
2.通过==反射==来创建
3.==clone拷贝==进行创建
4.==反序列化==进行创建

# 7.什么是集合
集合就是==存放数据对象引入==的==容器==。
集合类型主要有3种：set集合，list集合，Map集合

# 8.instanceof关键字的作用
用于比较一个==对象==是否是==某个类的实例==或==类的子类的实例==

# 9.this关键字的用法
this关键字就是指向==对象本身==
可以用来直接获取本类，或者属性，或者调用本类的构造器；

# 10.Hashcode的作用
hashcode是更具==对象内存地址==换算出来的一个值。
主要用途是在：比如：HashMap和HashSet时。根据==hashcode来决定一个存储的位置==，可以提高查询和存储的效率

# 11.关于浮点数在机器中的存放方式
一位==符号位==+8或11==指数位==+23或52==尾数位==构成
# 12.static的用法
用于修饰==属性==，==方法==，==内部类==，代码块。
1.可以使他们在不用创建对象实例的情况下，使用里面的==属性==和==方法==
2.可以用来定义==全局变量==，static修饰的属性存在于==运行时常量池中==
3.修饰的==静态代码块==，只会在==类加载的时候==，执行一次，可以用于初始化操作。
# 13.常用集合类有哪些
==Map接口和Collection接口==（可来tion）是所有集合框架的父接口。
1.Collection接口的子接口有：Set接口，List接口等
	1.Set接口的实现类有：`TreeSet`，`HashSet`，`LinkedHashSet`等
	2.List接口的实现类有：`ArrayList`，`LinkedList`，`Vector`(外科特)
2.Map接口的实现类有：`HashMap` ，`ConcurrentHashMap`(肯car润),`LinkedHashMap` ,`TreeMap` ，`HashTable`，`properties` 等
# 14.ArrayList和LinkedList的区别
ArrayList，Vector：中维护了一个被==transient(串西恩)修饰==的一个Object类型的==elementDate数组==，不被序列化。
LinedList:维护的是一个==双向循环列表==和==双向队列==。

## ArrayList，Vector，LinkedList底层数据结构
ArrayList使用无参构造器时，初始化elementDate容量为0，第一次扩容==默认扩容至10==个大小，再次扩容==为1.5倍==。==指定大小==的情况下，初始直接==默认初始化为指定大小==，之后1.5倍扩容。

Vector 初始化为10，默认2倍扩容。指定大小后，默认指定大小，后续2倍扩容

LinkedList底层维护了一个双向链表，维护了一个==first==和==last==分别指向==首节点==和==尾节点==，
==每个节点==中维护了`prev` `next` `item` 三个属性，prev指向前一个，next指向下一个最终实现双向链表。



# 15.如何选择ArrayList和LinkedList
1.==改查==多使用ArrayList
2.==增删==多使用LinkedList

# 16.super关键字的用法
super是指向的是自己==最近父类==，可以调用==父类的成员变量==，引用==父类构造器==

# 17.this和super同异
调用构造器时，两者都要放在==构造器第一行==。且==不能==重复出现==this和super在一个构造器==中。
两者由于指向的是对象，都不能在static的环境中使用

# 18.类加载的时机
1.==通过new创建实例==的时候 
2.创建==子类对象实例==，==父类对象跟随加载==
3.使用类的==静态成员==时（静态属性，静态方法）


# 19.java的四种引用
1.强引用
2.软引用
3.弱引用
4.虚引用
1. 强引用是我们平常用得==最多的引用==，==在OOM时也不会被回收==
2. 软引用在==内存不足的时==，==会被回收==
3. 弱引用 ==被JVM发现==就会==被回收==
4. 虚引用 和弱引用差不多，在==回收之前==就会被放入==ReferenceQueue队列==中

# 20.什么是jdk 和JRE
JDK 是 ==Java 开发⼯具包==
JRE 是 ==Java 运⾏时环境==，包括了 ==Java 虚拟机==）和 ==Java 标准类库==

（JVM）和 Java 标准类库（Java API）。
1. JDK =JRE+开发工具（如：javac,java编译工具）
2. JRE =JVM+JavaSE
#  21代码块和静态代码块的区别
1. ==代码块==的调用==优先级==**高于**==构造器==
2. 代码块，每==创建一个对象==就会被调用
3. 静态代码块，它会随着==[[Java面试题#18.类加载的时机|类的加载而执行]]==，并且只会执行一次
# 22.面向对象和面向过程的区别
1. 面向过程注重的是==函数和过程的调用==
2. 面向对象是以==对象为中心==的编程方式，通过==封装继承多态==等特性==实现代码的组织和复用==
# 23.HashMap的长度为什么是2的N次方
为了==提高HashMap的存储数据的效率==，尽可能==减少Hash值的碰撞==。
在代码中：==采用二进制与==，==相比于余==能提高运行效率。
通过==hash%length==可以得到==存储的位置==，但在
在==HashMap存储==判断时是通过 ==hash&(length-1)==要等于==hash%length==的==前提是要length的长度为2的N次==方。

# 24.List,Set,Map三者的区别是？
1. List它是一个==有序的容器==，存入顺序和取出顺序一致，==元素可重复==，可以==插入多个Nul==l,==元素有索引==。
2. Set是一个==无序容器==，==不可以存入重复的元素==，只==允许一个Null==。
3. Map是一个==键值对集合==，==key无序唯一==，==value允许重复==
# 25.集合和数组的区别
1. 数组是==固定长度的==，集合是==可变长度的==
2. 数组存储==可以是引用类型==，也可以是==基本数据类型==。集合==只能是引用类型==
3. 数组的存储元素必须是==同一个数组类型==，而集合==可以是不同的数据类型==

# 26.如何保证数据库和缓存的双写一致性
1. 第一种是==串行化==，但会导致吞吐量下降
目前常用的4种
	1. 写缓存，在写数据库
	2. 写数据库，再写缓存
	3. 删缓存，再写数据库
	4. 先写数据库，再删除缓存
- 先写缓存再写数据库最严重的问题是在如果写完缓存后，发生网络波动会导致数据库与缓存不一致
- 先写数据库再写缓存，也是会出现再写完数据库后出现网络问题而导致数据库缓存不一致
- 先删缓存，再写数据库，但在A在删除缓存后，出现网络波动，而B此时得到缓存为空，会查询数据库，写入缓存，A波动结束，在修改数据库，也会导致不一致问题
- 先写数据库，在删缓存，可以解决大多数问题。就算我们，我们网络波动，没有删除缓存，也只会发生一次从缓存读取旧数据的情况。
# 27.HashMap与HashTable的区别
1. HashMap是==线程不安全==的，HashTable是==线程安全==的
2. HashMap的key,Value==可以设为null==,而HashTable的key,Value==不可以设为null==
3. ==初始的容量==大小和每次==扩容大小不同==
备注（HashTable的性能不如ConCurrentHashMap）

# 28.红黑树的特征
1. **节点**是==黑色或红色==
2. **根节点**是==黑==
3. **叶子**节点为==红==，那么**子节**点==必是黑==
4. 指向**空的节点**，为==黑==
5. **节点**到**其所有孙子节点**上包含==相同数量==的==黑节点==

# 29.final ,finally,finalize的区别

[[Java面试题#5.final有什么用？|final]]
finally 一般作用于try-catch的代码块中，无论是否有异常都会执行
finalize是一个方法，一般==由垃圾回收器来调用==，进行垃圾回收对象==是否可回收的最后判断==

# 30. String,StringBuffer,StringBuider的区别
1. String是只读的字符串，每次对==String操作都会生成一个新的对象==，从==底层看是一个final char数组==
2. StringBuffer和StringBuider是==可变的字符串数组==，不过==StringBuffer是线程安全==，==StringBuider是线程不安全的==
# 31.反射的定义
在java中==只要给定类的名字==，就可以通过反射机制得==到类的所有信息==。
# 32.equals和\==的区别
\==是比较==地址是否相同==，即指向的是否是同一个对象
equals==默认是比较地址==，我们可以==重写来让他比较值是否相同==，比如String，Interger默认是重写了equals方法比较值是否相同

# 33.线程和程序和进程的概念
1. ==进程==是程序的==一次执行过程==，是==系统运行程序的基本单位==
2. ==程序==是指，存储在==磁盘中的数据和指令文件==
3. 线程是指,==比进程更小的单位==，==一个进程中可以有多个线程==
# 34.浅拷贝和深拷贝
1. 浅拷贝：是指==增加了一个指针指向==了已存在的==内存地址==
2. 深拷贝：==增加一个指针==指向了==一个新开辟的内存==
# 35.集合底层数据结构（HashSet,LinkedHashSet,TreeSet,HashMap的数据结构）
[[Java面试题#ArrayList，Vector，LinkedList底层数据结构]]

1. HashSet 是基于HashMap实现，底层采用==HashMap==
2. LinkedHashSet继承于HashSet，内部采用==LinkedHashMap==来实现
3. TreeSet是由==红黑树==来实现
4. HashMap是由==数组+链表+红黑树==来实现

HashMap在jdk8后是由==数组+链表+红黑树====组成，HashMap==初始容量为16==，当达到==一定的阈值==的时候就会扩容，在默认情况下==负载因子达到容量的0.75==倍就会扩容。按照==当前容量左移一位，也就是2倍==。在HashMap中元素以==Node节点以链表的形式==保存在数组里，当==链表长度大于等于8==，就会判断==数组大小是否大于等于64==，如果大于就会将==链表转换成红黑树的形式==。在加入一个元素的时候，会将元素的==hashcode异或hashcode右移16位得到的hash值==，用hash值&（容量-1）得到索引值。加入元素，会判断没有元素就直接加入，有元素的情况下，比较key相同会覆盖，不同会加入链表。


# 36.方法调用的机制
方法执行的时候会在==栈中开辟空间==，执行完后销毁，==对象存放在堆中==。

# 37.Object常用方法
1.equlas 2.clone 3.finalize(fly呢来) 4.hashcode 5.wait 6.notify 7.notifyall

# 38.short s1=1;s1=s1+1有错吗
有错，+1会转换成int类型

# 39.IO流的分类
按==流向==可分为：输入流，输出流
按==单元==可分为：字节流，字符流
按**角色**可分为：节点流，处理流


# 40.float f=3.4是否正确
错误应该为：float f=3.4f

# 41.JAVA自动装箱与拆箱
**自动装箱**就是将基本数据类型变成对应的==包装器类型==如int变成Integer。
调用对应包装器类型的`valueOf()`方法。
在valueOf方法中数组在`[-128,127]`之间，那么==包装器类型直接指向==已经==存在的引用对象==。
否者是通过`new Integer()`的方法创建出来的，地址会发生变化。

**拆箱**是 调用比如`Integer.IntValue`方法。

# 42.重写和重载的区别
**重写**发生在父子类中，方法名，参数列表必须相同。（父类修饰符为private的方法不能重写）

**重载**发生在==同一个类中==，==**方法**名相同==，==参数类型不同，个数不同，顺序不同==


# 43.JDK 动态代理和 CGLIB 动态代理的区别是什么？
主要区别是：
1. 在==实现⽅式上==：JDK 动态代理是通过==反射实现==的，⽽CGLIB动态代理是通过==继承⽬标类==来实现
的。
2. JDK 动态代理要求==⽬标类必须要实现接⼝==，CGLIB 通过==继承实现，不能代理final 类==。
3. JDK 动态代理是 Java ⾃带的库，，⽽ CGLIB 动态代理需要依赖 cglib 库

# 44.内部类的分类
1. **成员内部类**：定义在==类内部==，但==在⽅法外部==的类。它==可以访问外部类==的所有成员变量和⽅
法；
2. **静态内部类**：定义在==类内部==，但使==⽤ static 修饰==的类。它==只能访问外部类的静态成员==变量
和⽅法；
3. **局部内部类**：定义在==⽅法内部的类==。它只==能访问⽅法内部的 final 变量==和⽅法参数；
4. **匿名内部类**：==没有类名==的内部类，通常⽤于==创建只需要使⽤⼀次的类==。