---
日期: 2024-03-18
tags:
  - SQL
  - 底层原理
  - 基本概念
---

# [[mysql]]的体系结构
- 连接层
	-和客户端进行连接服务，包括授权认证等
- 服务层
	-大多数核心服务，sql接口，优化，缓存。跨存储引擎的功能实现，如：过程，函数
- 引擎层（更具不同引擎有所不同）
	-负责数据的存储提取,由具体的存储引擎决定
- 存储层
	-存储数据在文件系统，并于存储引擎交互
![[Pasted image 20240318201553.png]]

# 存储引擎
描述：存储引擎是存储数据，建立索引，更新/查询数据等技术实现。存储引擎是基于表的而不是基于库的。
### Innodb
特点：
	1. [[mysql#^8ff1f1|DML]]操作遵循[[mysql面试题#3.数据库事务的特性（ACID）|ACID]]模型，支持事务
	2. 行级锁
	3. 支持外键
# 索引
![[mysql面试题#8.数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？]]

## 索引结构

| 索引结构            | 描述                  | 支持类型                 |
| --------------- | ------------------- | -------------------- |
| **B+树索引**（默认）   | **大部分支持**           | Innodb,MyISAM,Memory |
| Hash索引          | 不支持范围查询如>,<,between | Memory               |
| R-tree（空间索引）    |                     | MyISAM               |
| Full-text(全文索引) |                     | Innodb(5.6后),MyISAM  |

树的动态演变过程参考网站：[数据结构可视化 (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
### **B-tree(多路平衡查找树)**
![[Pasted image 20240330134434.png]]
每插入一个元素进来，当==元素==大于==阶数==存储的key,就会发生**中间元素向上分裂**。 
如此时插入2456。就会变成【1800，1888，1980，2000，2456】 ->1980就会向上分裂。
【0123，0345，1200，1567，1980】->1200向上分裂
![[Pasted image 20240330135350.png]]
![[Pasted image 20240330135526.png]]
### **B+树** 
1. ==所有的元素==都会出现在==叶子节点==。
2. ==叶子节点==形成一个==单向链表==。 
3. ==非叶子节点==起到==索引的作用==
![[Pasted image 20240330140233.png]]
MySQL对经典的B+树进行了优化。在B+树的基础上，增加了==指向相邻叶子节点的链表指针==。
![[Pasted image 20240330140537.png]]


## 索引分类
主要

| 分类   | 特点  | 关键字      |
| ---- | --- | -------- |
| 主键索引 | 1个  | primary  |
| 唯一索引 | 多个  | unique   |
| 常规索引 | 多个  |          |
| 全文索引 | 多个  | fulltext |

==按索引存储形式==分为：（Innodb）

| 分类                  | 含义                                   | 特点        |
| ------------------- | ------------------------------------ | --------- |
| **聚集索引**            | 将**数据存储与索引**放到一块，索引的叶子节点保存行数据        | 必须有，且只要一个 |
| **二级索引**（**非聚集索引**） | 数据与索引**分开存储**，索引结构的**叶子节点关联的是对于的主键** | 可以存放多个    |

**聚集索引选取规则**：
1. 如果*存在主键*，**主键索引**就是聚集索引
2. 如果*不存在主键*，将使用第一个**唯一索引**作为聚集索引
3. 如果都没有，会隐式的生成一个rowid作为隐藏的聚集索引。
[[mysql面试题#1.表没有主键可以吗？可以不设置主键吗]]




# 索引使用原则
## 最左前缀法则
1. 如果索引了多列(联合索引)，要遵循最左前缀法则，最左侧索引必须存在。
2. 查询从索引的最左列开始，并且不跳过索引中的列，如果跳过的话会部分失效。
> [!NOTE]- 联合索引为（name, age, sex）是否走索引
>**满足最左前缀原则**
> - ✅ name="LI" and age=18 and sex="男" 
> - ✅  age=18 and  name="LI" and sex="男"  //和放的位置无关
>**不满足最左前缀原则**
> - ❎ name="LI" and age=18 
> - ❎ age=18 and sex="男" 
> - ❎ sex="男" 
> **部分生效**
> - 🟩 name="LI" and sex="男"  //name生效，而sex失效

## 范围查询
1. 如果使用><会导致==后面代码的索引失效==
2. 用>=代替>。<=代替<

> [!NOTE]- 联合索引为（name, age, sex）范围查询
>  **部分生效**
> - 🟩 name="LI" and age>18 and sex="男"  //name生效，而sex失效
## 索引失效
**不满足最左前缀原则**
**范围查询**
**函数运算,字符不加引号**
	使用函数，字符串不加''不走会不走索引
**模糊查询**
	 模糊查询前面加%会失效 `❎name="%智高" ✅name="潘%"`
**or连接的条件**
	两边都要有索引才会走索引 `❎id="1" or desc="没有描述"`
[[mysql面试题#索引失效]]


## Mysql自动选择索引
**当索引比全表慢时**，Mysql会自动选择全表扫描。
	如：当