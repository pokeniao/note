---
日期: 2024-03-18
tags:
  - SQL
  - 底层原理
  - 基本概念
---

# [[mysql]]的体系结构
- 连接层
	-和客户端进行连接服务，包括授权认证等
- 服务层
	-大多数核心服务，sql接口，优化，缓存。跨存储引擎的功能实现，如：过程，函数
- 引擎层（更具不同引擎有所不同）
	-负责数据的存储提取,由具体的存储引擎决定
- 存储层
	-存储数据在文件系统，并于存储引擎交互
![[Pasted image 20240318201553.png]]

# 存储引擎
描述：存储引擎是存储数据，建立索引，更新/查询数据等技术实现。存储引擎是基于表的而不是基于库的。
### Innodb
特点：
	1. [[mysql#^8ff1f1|DML]]操作遵循[[mysql面试题#3.数据库事务的特性（ACID）|ACID]]模型，支持事务
	2. 行级锁
	3. 支持外键
# 数据存储形式
表空间 【段【区【页16K【行【字段】行】页】区】段】 
-  区大小为1M，有64个页。
-  页大小为16K。
- 每个页*至少*包含2行数据
![[Pasted image 20240404140247.png]]
## 主键插入页
**顺序插入**：一个一个往后插入，当**一个页满了，新建一个页**。
**乱序插入**：
- **页分裂**：按有序插入，当发现==需要插入的页满==的时候，会新建一个页，==并将原来的页二分==，将内容插入。最后==修改页链表指针的指向==。	 
	![[Pasted image 20240404141612.png]]
- **页合并**： 当删除数据的时候。此删除不会物理删除，而是逻辑删除。==删除达到一定阈值==（默认一半），就会*查找附近的页*合适的会将==数据覆盖两个页合并成一个页==。
	![[Pasted image 20240404142533.png]]
# 索引
![[mysql面试题#^mj8rl3]]

## 索引结构

| 索引结构            | 描述                  | 支持类型                 |
| --------------- | ------------------- | -------------------- |
| **B+树索引**（默认）   | **大部分支持**           | Innodb,MyISAM,Memory |
| Hash索引          | 不支持范围查询如>,<,between | Memory               |
| R-tree（空间索引）    |                     | MyISAM               |
| Full-text(全文索引) |                     | Innodb(5.6后),MyISAM  |

树的动态演变过程参考网站：[数据结构可视化 (usfca.edu)](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)
### **B-tree(多路平衡查找树)**
![[Pasted image 20240330134434.png]]
每插入一个元素进来，当==元素==大于==阶数==存储的key,就会发生**中间元素向上分裂**。 
如此时插入2456。就会变成【1800，1888，1980，2000，2456】 ->1980就会向上分裂。
【0123，0345，1200，1567，1980】->1200向上分裂
![[Pasted image 20240330135350.png]]
![[Pasted image 20240330135526.png]]
### **B+树** 
1. ==所有的元素==都会出现在==叶子节点==。
2. ==叶子节点==形成一个==单向链表==。 
3. ==非叶子节点==起到==索引的作用==
![[Pasted image 20240330140233.png]]
MySQL对经典的B+树进行了优化。在B+树的基础上，增加了==指向相邻叶子节点的链表指针==。
![[Pasted image 20240330140537.png]]


## 索引分类
主要

| 分类   | 特点  | 关键字      |
| ---- | --- | -------- |
| 主键索引 | 1个  | primary  |
| 唯一索引 | 多个  | unique   |
| 常规索引 | 多个  |          |
| 全文索引 | 多个  | fulltext |

==按索引存储形式==分为：（Innodb）

| 分类                  | 含义                                   | 特点        |
| ------------------- | ------------------------------------ | --------- |
| **聚集索引**            | 将**数据存储与索引**放到一块，索引的叶子节点保存行数据        | 必须有，且只要一个 |
| **二级索引**（**非聚集索引**） | 数据与索引**分开存储**，索引结构的**叶子节点关联的是对于的主键** | 可以存放多个    |

**聚集索引选取规则**：
1. 如果*存在主键*，**主键索引**就是聚集索引
2. 如果*不存在主键*，将使用第一个**唯一索引**作为聚集索引
3. 如果都没有，会隐式的生成一个rowid作为隐藏的聚集索引。
[[mysql面试题#1.表没有主键可以吗？可以不设置主键吗]]




## 索引使用原则
### 最左前缀法则
1. 如果索引了多列(联合索引)，要遵循最左前缀法则，最左侧索引必须存在。
2. 查询从索引的最左列开始，并且不跳过索引中的列，如果跳过的话会部分失效。
> [!NOTE]- 联合索引为（name, age, sex）是否走索引
>**满足最左前缀原则**
> - ✅ name="LI" and age=18 and sex="男" 
> - ✅  age=18 and  name="LI" and sex="男"  //和放的位置无关
>**不满足最左前缀原则**
> - ❎ name="LI" and age=18 
> - ❎ age=18 and sex="男" 
> - ❎ sex="男" 
> **部分生效**
> - 🟩 name="LI" and sex="男"  //name生效，而sex失效

### 范围查询
1. 如果使用><会导致==后面代码的索引失效==
2. 用>=代替>。<=代替<

> [!NOTE]- 联合索引为（name, age, sex）范围查询
>  **部分生效**
> - 🟩 name="LI" and age>18 and sex="男"  //name生效，而sex失效
### 索引失效
**不满足最左前缀原则**
**范围查询**
**函数运算,字符不加引号**
	使用函数，字符串不加''不走会不走索引
**模糊查询**
	 模糊查询前面加%会失效 `❎name="%智高" ✅name="潘%"`
**or连接的条件**
	两边都要有索引才会走索引 `❎id="1" or desc="没有描述"`
[[mysql面试题#索引失效]]


### Mysql自动选择索引
**当索引比全表慢时**，Mysql会自动选择全表扫描。
	如：当获取的数据几乎为全表数据时。
### SQL提示
SQL提示是优化数据库的重要手段。用于提示Mysql使用的索引类型


### 覆盖索引
是指使用==查询结果只含索引字段==，不会发生回表查询
**避免使用\***，因为\*会包含非索引字段，会发生回表查询
如：
> [!NOTE]- 主键索引为id ，联合索引（name,age) 
> 是否回表
> ❎select id,name,age from user where name=""; 
> 	*不需要回表原因*：因为二级索引包含了id,而二级索引本身为name和age
> ❎select \*  from user where  id=1;
> 	*不需要回表原因*：聚集索引id下包含整个row
> ✅select id,name,age,sex from user where name=""; 
> 	*回表原因*：二级索引中不包含sex，需要回表

### 前缀索引
>**当字段类型为字符串(varchar, text等)时,** 这会让索引变得很大,查询时浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

 **前缀长度的设置**
 (越接近1越好)选择性计算= **选择字段不重复的数量**/**总数**
 select `count (distinct substring (email,1,5))` / `count (*)`  from tb_user;


## 索引设计原则
1. **数据量较大**，**查询频繁**
2. 常用于`where`,`order by`,`group by` 的字段建立索引
3. **区分度高**或**唯一的**建立索引
4. 字段长的，**使用前缀索引**
5. **尽量使用联合索引**，**减少单列索引**。查询时，联合索引很多时候可以覆盖索引，避免回表，节约存储空间
6. 如果索引列不能存储NULL值，创建表时用NOT NULL约束。当优化器知道每列是否包含NULL时，可以确定那个索引最有利于查询。

# 索引组织表
在InnoDB存储引擎中==,表数据都是根据主键顺序组织存放的==,这种存储方式的表称为索引组织表(IOT)。

# SQL优化
**一.  插入时**
1.  *批量插入*，减少数据库的连接，但也不推荐超过1000条
2. *手动提交事务*：因为每一条Insert成功会提交事务，会频繁开启提交事务，所以多条insert时，手动的设置开启与提交事务	
3. *主键顺序插入*：
4. *大批量插入*: 如100w条 ,[[mysql#大批量数据|使用load代替insert]]
**二. 主键优化**
1. *降低主键长度*
2. *尽量顺序插入*
3. *尽量不要使用UUID做主键*，或是其他自然的主键，如身份证号码。原因：长，无序
**三. order by优化**
1. 