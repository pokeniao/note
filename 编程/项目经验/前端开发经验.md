---
日期: 2024-03-19
aliases:
  - vue前端开发经验
tags:
  - 开发经验
---
# 父子之间的传递参数（Vue3的组件通讯）
- [x] 方法用过 ✅ 2024-03-19
1. **Props和Events传递**
	- **父传子Props**： 子绑定 `:message="传入的值"` 子通过定义`props: ['message']`
> [!NOTE]- 解释
>`props: ['message']` 的作用是定义了一个名为 `message` 的prop。这意味着父组件可以通过 `message` 这个prop向子组件传递数据。子组件可以在其模板中使用 `message` 来访问从父组件传递过来的数据。
>`props: ['message']` 声明了一个名为 `message` 的prop，它告诉[[Vue]]组件需要接收一个名为 `message` 的属性。

```vue fold:"父传子Props"
<!-- ParentComponent.vue -->
<template>
  <ChildComponent :message="parentMessage" @updateMessage="handleUpdateMessage" />
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: {
    ChildComponent
  },
  data() {
    return {
      parentMessage: 'Hello from parent'
    };
  },
  methods: {
    handleUpdateMessage(message) {
      this.parentMessage = message;
    }
  }
};
</script>
--------------------------------------------------------------------------------
<!-- ChildComponent.vue -->
<template>
  <div>
    <p>{{ message }}</p>
  </div>
</template>

<script>
export default {
  props: ['message']
};
</script>

```
- **子传父Events传递**：子通过`this.$emit('messageToParent', 'Hello from child');` 发送，父监听`@messageToParent="handleMessageFromChild"`
	
> [!NOTE]- 解释
> 子组件可以通过==触发事件==来传递数据给父组件。父组件==通过监听==这些事件来执行相应的处理逻辑。
> `'messageToParent'` 是要触发的事件的名称，这里是自定义的事件名称
> `'Hello from child'` 是要传递给父组件的数据，可以是任何你想要传递的值

```vue fold:"子传父Events"
<template>
  <button @click="sendMessageToParent">Send Message to Parent</button>
</template>

<script>
export default {
  methods: {
    sendMessageToParent() {
      this.$emit('messageToParent', 'Hello from child');
    }
  }
  
};
</script>
--------------------------------------------------------------------------------
<template>
  <ChildComponent @messageToParent="handleMessageFromChild" />
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: {
    ChildComponent
  },
  methods: {
    handleMessageFromChild(message) {
      console.log('Message from child:', message);
    }
  }
};
</script>

```
需要注意：`this.$emit` 只能使用在`methods:{}` 中 而不能使用在 `setup(){}`中,在setup中需要写成
```vue fold:"emit('GetData',resp.data.content)"
<script>
setup(props,{emit}) {
	const SendTypeNameMethod = (typeName) => {
		emit('GetData',resp.data.content);
	}
}
</script>
```
*原因*：[[Vue概念#^4da24e|setup没有上下文]] 上述代码还用了解构赋值[^解构赋值]

[^解构赋值]: [[Vue概念#解构赋值]] 


# 路由的时候传递参数
注意：路由传递参数==不能传递数组==，所以我们传递==一个参数过去后再搜索==
*传递参数：*![[Vue#^20a2b6]]
*接受参数：*
mounted中接受参数：`this.$route.params.productId;`
setup接受参数：
```js
import { useRoute } from 'vue-router'; 
const route=useRoute();
productId.value =route.params.productId;
```

> [!warning]- 注意
> 1.注意useRouter 和useRoute 区别
> 2.`const router=useRouter();` `const route=useRoute();` 要写在setup中

*代码*
```vue fold:具体代码示例
<!-- Home.vue -->
<template>
  <div>
    <h1>首页</h1>
    <div v-for="product in products" :key="product.id" @click="goToPurchase(product.id)">
      <h2>{{ product.name }}</h2>
      <p>{{ product.description }}</p>
      <p>价格：{{ product.price }}</p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      products: [
        { id: 1, name: '商品1', price: 100, description: '这是商品1的描述' },
        { id: 2, name: '商品2', price: 200, description: '这是商品2的描述' },
        // 其他商品...
      ]
    };
  },
  methods: {
    goToPurchase(productId) {
      this.$router.push(`/purchase/${productId}`);
    }
  }
}
</script>
------------------
<!-- Purchase.vue -->
<template>
  <div>
    <h1>购买页面</h1>
    <h2>{{ product.name }}</h2>
    <p>{{ product.description }}</p>
    <p>价格：{{ product.price }}</p>
    <!-- 这里放置购买页面的其他内容 -->
  </div>
</template>

<script>
export default {
  data() {
    return {
      product: null
    };
  },
  mounted() {
    // 通过路由参数获取商品ID
    const productId = this.$route.params.productId;
    // 根据商品ID从后端或本地数据获取商品信息
    this.product = this.getProductById(productId);
  },
  methods: {
    getProductById(productId) {
      // 根据商品ID从后端或本地数据获取商品信息
      // 这里是模拟的数据，实际项目中可能需要发送请求获取数据
      return {
        id: productId,
        name: '商品1',
        price: 100,
        description: '这是商品1的描述'
      };
    }
  }
}
</script>
--------
{ path: '/', name: 'Home', component: Home }, 
{ path: '/purchase/:productId', name: 'Purchase', component: Purchase }
```


# 无限下拉
1. [[Vue#添加监听器|添加监听器]]监听下拉变化
```js
onMounted(() => {  
	window.addEventListener('scroll', handleResize);  
});
onUnmounted(() => {  
	window.removeEventListener('scroll', handleResize);  
});
```
2. 编写调用handleResize方法
```js fold:下拉方法handleResize
const scrollVLoading =ref(false);
const handleScrollMethod = () => {  
	//获得页面的高度
	const scrollHeight=document.body.scrollHeight;  
	//获得页面当前下拉的高度
	const scrollTop=document.body.scrollTop ||document.documentElement.scrollTop;  
	//计算是否快到底
	const distance=scrollHeight-scrollTop  
	//快到底了，判断是否上锁
	if (distance<1000 && !scrollVLoading.value) {  
	console.log("快到低了")  
	// 加载更多商品数据,判断是是否还能获取
	if(pagination.current<=pagination.pages){  
	scrollVLoading.value = true;  
	getServicesMethod();  
	}else {  scrollVLoading.value = true;  
		}  
	}  
}
```
3. 获取内容
```js fold:具体分页获取信息方法
const getServicesMethod = () => {  
		axios.get("/manager/mainShow/getServices/" + pagination.current + "/" + pagination.pageSize).then(resp => {  
	if (resp.data.code === 200) {  
		//追加数据
		services.value = [...services.value, ...resp.data.content.records];  
		pagination.pageSize = resp.data.content.size;  
		pagination.current = resp.data.content.current+1;  
		pagination.total = resp.data.content.total;  
		pagination.pages= resp.data.content.pages;  
		//放行
		scrollVLoading.value=false;  
		}  
	})   
}
```
>*其他相关：*
>[[Vue]]
